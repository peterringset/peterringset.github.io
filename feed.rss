<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Peter Ringset</title><description>My name is Peter, and I'm an iOS developer. On this blog I'll share my thoughts on various subjects in iOS development, and tips and tricks around developing apps for the Apple ecosystem.</description><link>https://peterringset.dev</link><language>en</language><lastBuildDate>Sat, 27 Nov 2021 19:01:13 +0100</lastBuildDate><pubDate>Sat, 27 Nov 2021 19:01:13 +0100</pubDate><ttl>250</ttl><atom:link href="https://peterringset.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://peterringset.dev/articles/namespaced-colors</guid><title>Creating namespaces for named colors in Xcode</title><description>Did you know that you can namespace your colors in asset catalogs?</description><link>https://peterringset.dev/articles/namespaced-colors</link><pubDate>Thu, 26 Nov 2020 16:02:00 +0100</pubDate><content:encoded><![CDATA[<p>Xcode's feature for named colors has been around for a few years now. When it first was introduced it was a big improvement on the existing system for vending colors, but one of the major drawbacks that were never addressed is the problem of naming safety. The current initializer takes the name as a <code>String</code>, which leads to a couple of problems. The most obvious one is that it is prone to typos, but perhaps more importantly, it does not guarantee that the name will actually resolve to a <code>UIColor</code> instance in the future if for instance the color is renamed.</p><h2>#colorLiteral</h2><p>Xcode does have a built-in mechanism for working with color literals, namely the <code>#colorLiteral(red:green:blue:alpha:)</code> statement, but unfortunately this suffers from a major drawback. The color literal only refers to the RGBA values and not the name of the color. This means that the literal will stay unchanged if the source color changes. The color literals will also be hard to use in apps that support both dark and light modes.</p><p>This leads us to think that we need to find a better way for structuring and naming colors in apps that use named colors and asset catalogs.</p><h2>Design systems</h2><p>Another motivation for structuring and naming our color use is when working with design systems. Most designers worth their salt will have a clearly defined color palette – not only for the primary, secondary, text, and similar colors but also hairline borders, shadows, and similar. This means that there will be at least a handful of colors to work with, and structuring our color system is starting to make more and more sense.</p><h2>First stab – <code>static</code> properties</h2><p>Usually, this results in developers declaring their colors in some way, for instance as an extension on <code>UIColor</code>:</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static var</span> brandMain: <span class="pre code type">UIColor</span> { <span class="pre code type">UIColor</span>(named: <span class="pre code string">"brandMain"</span>)! }
    <span class="pre code keyword">static var</span> brandSecondary: <span class="pre code type">UIColor</span> { <span class="pre code type">UIColor</span>(named: <span class="pre code string">"brandSecondary"</span>)! }
}
</code></pre><p>This solution is quite a bit better, but there is still room for improvement. The name of the color is written twice, or three times actually, if we count the name in the asset catalog as well.</p><h2>Second stab – <code>enum</code>-backed initialization</h2><p>To get ease the work of declaring things multiple times, and help implement changes and additions to our color palette we can use <code>String</code>-backed <code>enum</code>s to name our colors.</p><pre><code><span class="pre code keyword">enum</span> BrandColor: <span class="pre code type">String</span> {
    <span class="pre code keyword">case</span> main, secondary, text
}

<span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static func</span> brand(<span class="pre code keyword">_</span> name: <span class="pre code type">BrandColor</span>) -&gt; <span class="pre code type">UIColor</span> {
        <span class="pre code keyword">guard let</span> color = <span class="pre code type">UIColor</span>(named: name.<span class="pre code property">rawValue</span>) <span class="pre code keyword">else</span> {
            <span class="pre code call">fatalError</span>(<span class="pre code string">"Failed to load named color"</span>)
        }
        <span class="pre code keyword">return</span> color
    }
}
</code></pre><p>To be even more thorough we can also use the more complicated initializer</p><pre><code><span class="pre code type">UIColor</span>(named: name.<span class="pre code property">rawValue</span>, in: <span class="pre code type">Bundle</span>(for: <span class="pre code type">PrivateClass</span>.<span class="pre code keyword">self</span>), compatibleWith: <span class="pre code keyword">nil</span>)
</code></pre><p>with an empty class named <code>PrivateClass</code> (or any other class that belongs to the same bundle) to be able to use these colors outside of our bundle.</p><p>This leaves us with a pretty solid solution for handling colors in our app. This can be more than enough for a lot of apps. But, sometimes we can run into situations where we have a very large number of colors to handle. For instance, there could be the main palette, containing three or four colors used to color UI elements. Then there could be a second palette to handle text, maybe three or four colors there as well. Additionally, we could have a third palette for data visualizations, like cake diagrams and similar. This could add another six or seven colors. To add to this complexity, we will in many cases also run into situations where a text color is almost the same as a UI element color, only slightly darker. And this is what motivates our final improvement.</p><h2>Third stab - Namespaces</h2><p>A well-known feature in asset catalogs is to use folders to organize the assets. The folders are not actually folders though, they only help with grouping. Each asset's name still has to be unique to avoid naming collisions. But there is a more obscure feature we can also use – folders can actually provide namespaces. To enable this we'll have to select the folder in the left list and tick the <code>Provides Namespace</code> box at the top-right menu of the screen.</p><img src="https://peterringset.dev/images/namespaced-colors/provides-namespace.png" alt="Asset catalog"/><p>Our color names will now be <code>main/green</code>, <code>main/purple</code>, and <code>main/red</code>, which means that we can have multiple colors named <code>red</code>, just organized into different namespaces.</p><p>To support this new feature in code we will expand on our color instantiation a bit.</p><pre><code><span class="pre code keyword">protocol</span> NamespacedColor: <span class="pre code type">RawRepresentable</span> <span class="pre code keyword">where</span> <span class="pre code type">RawValue</span> == <span class="pre code type">String</span> {
    <span class="pre code keyword">var</span> namespace: <span class="pre code type">String</span> { <span class="pre code keyword">get</span> }
}

<span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static func</span> named&lt;N: <span class="pre code type">NamespacedColor</span>&gt;(<span class="pre code keyword">_</span> value: <span class="pre code type">N</span>) -&gt; <span class="pre code type">UIColor</span> {
        <span class="pre code keyword">let</span> name = <span class="pre code string">"</span>\(value.<span class="pre code property">namespace</span>)<span class="pre code string">/</span>\(value.<span class="pre code property">rawValue</span>)<span class="pre code string">"</span>
        <span class="pre code keyword">guard let</span> color = <span class="pre code type">UIColor</span>(named: name, in: <span class="pre code type">Bundle</span>(for: <span class="pre code type">PrivateClass</span>.<span class="pre code keyword">self</span>), compatibleWith: <span class="pre code keyword">nil</span>) <span class="pre code keyword">else</span> {
            <span class="pre code call">fatalError</span>(<span class="pre code string">"Failed to load color asset"</span>)
        }
        <span class="pre code keyword">return</span> color
    }
}
</code></pre><p>Then we declare our different namespaces.</p><pre><code><span class="pre code keyword">enum</span> MainColors: <span class="pre code type">String</span>, <span class="pre code type">NamespacedColor</span> {
    <span class="pre code keyword">case</span> red, green, blue
    <span class="pre code keyword">var</span> namespace: <span class="pre code type">String</span> { <span class="pre code string">"main"</span> }
}

<span class="pre code keyword">enum</span> TextColors: <span class="pre code type">String</span>, <span class="pre code type">NamespacedColor</span> {
    <span class="pre code keyword">case</span> red, purple, cyan
    <span class="pre code keyword">var</span> namespace: <span class="pre code type">String</span> { <span class="pre code string">"text"</span> }
}
</code></pre><p>and instantiate our colors using</p><pre><code><span class="pre code keyword">let</span> color1: <span class="pre code type">UIColor</span> = .<span class="pre code call">named</span>(<span class="pre code type">MainColors</span>.<span class="pre code property">blue</span>)
<span class="pre code keyword">let</span> color2: <span class="pre code type">UIColor</span> = .<span class="pre code call">named</span>(<span class="pre code type">TextColors</span>.<span class="pre code property">cyan</span>)
</code></pre><p>This lets us declare our colors in a structured way in our asset catalogs and write very small amounts of code to let us have a compile-safe instantiation of our colors.</p><h2>Bonus round – Tests</h2><p>To add a final layer of safety we can also add tests to make sure that all our color code resolves to actual colors. To do this we will use the <code>CaseIterable</code> protocol, and make each color enum conform to it. This allows us to iterate over all cases and check that they instantiate correctly.</p><pre><code><span class="pre code keyword">func</span> testMainColors() <span class="pre code keyword">throws</span> {
    <span class="pre code keyword">for</span> color <span class="pre code keyword">in</span> <span class="pre code type">MainColors</span>.<span class="pre code property">allCases</span> {
        <span class="pre code call">XCTAssertNotNil</span>(<span class="pre code type">UIColor</span>.<span class="pre code call">named</span>(color))
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/live-reloads-for-publish</guid><title>Live reloads for Publish</title><description>See how to get live reloads when developing/writing with Publish</description><link>https://peterringset.dev/articles/live-reloads-for-publish</link><pubDate>Mon, 19 Oct 2020 19:53:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish "Publish"">Publish</a> is a great tool to use when writing your own blog – I used it to write this blog. I think Publish is really great, and I love being able to use Swift for my blog posts. But when I was starting up, setting up my own blog, I really missed the possibility of using live reloads. I'm sure this is probably something that will come eventually be baked into the <code>publish</code> CLI, but at the time of writing it is not included.</p><p>When running the local webserver with <code>publish run</code> you still have to go into the browser and manually reload the page each time you've rebuilt the output directory (⌘+R). But there are a lot of ways you can solve this. A colleague of mine, who is a proficient web developer, tipped me on a node package called <a href="https://www.npmjs.com/package/live-server "live-server node package""><code>live-server</code></a>. It does exactly what you expect it to do. To run it you first have to make sure you have <a href="https://nodejs.org/en/ "Node.js"">Node</a> installed. Then you'll have to run</p><pre><code>cd <span class="pre code type">Output</span>
npx live-server
</code></pre><p>from the root of your publish project, and that's it. There's no dependency added to you project, just a simple one-liner to get your web-server up and running. If you're curious to how this actually works you can inspect the resulting html to see that it injects some javascript at the end of the html <code>&lt;body&gt;</code>, which sets up a socket to a locally running web server.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/building-a-state-driven-app</guid><title>Building a state driven app in SwiftUI using state machines</title><description>See how to use state machines to build a simple image searching application in SwiftUI.</description><link>https://peterringset.dev/articles/building-a-state-driven-app</link><pubDate>Tue, 18 Feb 2020 14:03:00 +0100</pubDate><content:encoded><![CDATA[<p>When developers are working on complex features we often talk about state. Many times we don’t want to deal with state, at least when it’s mutable. State complicates everything, especially when it can change. In this post, we’re going to look at how to deal with state in UIs, specifically iOS applications, but the principles should translate to almost any platform.</p><p>I’ve recently written <a href="https://medium.com/eggs-design/let-designers-and-developers-collaborate-through-state-diagrams-48a1d9a484df	"Let designers and developers collaborate through state diagrams"">a blog post about state diagrams and collaboration</a> between designers and developers. We’ll be looking at the same sample application in this post. In this post, however, we’re taking a more technical perspective and will be looking at how we can use the state machine to drive UI changes and respond to events. The sample code is also <a href="https://github.com/peterringset/StateMachineUI">available on GitHub</a> if you want to check it out in more detail.</p><h2>Sample application</h2><p>The main concept of our sample application is a search function that can search for images on <a href="https://pixabay.com/service/about/api/">pixabay</a>. We already have a design spec for our application, it looks like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/screens.jpg" alt="Design specification"/><p>There are five different screens in this UI: the empty start screen, the searching screen, the loading screen, and finally the result screen or the failure screen. The way these screens are laid out in the canvas above tells us something about how they are related to each other. We can already infer quite a bit about the UX and flow of this application by just looking at this canvas. For instance, the transition from the start screen to the searching screen is triggered by the user tapping in the search field. Similarly, the transition from the searching screen to the loading screen is triggered by the user tapping the search button in the bottom right of the keyboard. We see that transitioning to the loading screen will also mean firing a network request to the pixabay API. Since we know that network requests are prone to fail, we also have a failure screen for when that inevitably happens.</p><p>But what should happen when the user has reached one of these two “end states” (error or results) and wants to search again? It’s not entirely clear from the sketches, and we see that there is room for a more complete specification here.</p><h2>State diagrams</h2><p>To specify our design spec further we are going to use a state diagram. Our notation here will be circled text to represent states, and arrows with text to represent transitions between states, like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/state_diagram_example.jpg" alt="A state diagram"/><p>Note that the text next to each arrow is typically an event or action. In this case, we’re dealing with UIs, so a typical action can be a button tap, text field selection, and also external events like a network request returning a result. The state diagram for our sample application looks like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/state_diagram.jpg" alt="Our state diagram"/><p>We are defining some actions in our state diagram:</p><ul><li>Start search: the user taps the search text field to give it focus</li><li>Cancel: the user taps the cancel button that appears next to the text field</li><li>Search: the user taps the search button in the keyboard</li><li>Success: the network request to pixabay returned with results</li><li>Failure: the network request to pixabay failed</li></ul><p>This gives us a pretty complete picture of how this application is supposed to work, so now we can go over to implementation.</p><h2>Implementation</h2><p>Our sample application is implemented in SwiftUI, using the MVVM architecture. The structure of our application is a container view ( <code>ContentView</code>) that encapsulates our application window. This window has a corresponding view model that handles our logic and houses our state handling.</p><h3>The User interface</h3><p>The view hierarchy is pretty simple. Everything is wrapped in a <code>NavigationView</code>. The first view inside is a custom component, the <code>SearchBar</code> view, that wraps UIKit's <code>UISearchBar</code>. Below that is the main content of each screen, and that's going to vary with the state of our application.</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  <span class="pre code keyword">@ObservedObject var</span> viewModel: <span class="pre code type">ContentViewModel</span>
  
  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        <span class="pre code type">SearchBar</span>()
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span>
        <span class="pre code type">Spacer</span>()
      }
    }
  }
  
  <span class="pre code keyword">private var</span> content: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">switch</span> viewModel.<span class="pre code property">state</span> {
    ...
    }
  }
}
</code></pre><p>To implement our state diagram we’re using a state machine, that defines all the states and events (actions):</p><pre><code><span class="pre code keyword">class</span> StateMachine {
  <span class="pre code keyword">enum</span> State {
    <span class="pre code keyword">case</span> start, searching, loading, searchResults, error
  }
  <span class="pre code keyword">enum</span> Event {
    <span class="pre code keyword">case</span> startSearch, cancel, search, success, failure
  }
  ...
}
</code></pre><p>The state is going to influence both the search bar and the content below. The search bar can trigger events, and its appearance is dependent on the state. We start with the following view model:</p><pre><code><span class="pre code keyword">class</span> ContentViewModel: <span class="pre code type">ObservableObject</span> {
  <span class="pre code keyword">private let</span> stateMachine: <span class="pre code type">StateMachine</span>
  <span class="pre code keyword">private var</span> stateCancellable: <span class="pre code type">AnyCancellable</span>?

  <span class="pre code keyword">@Published var</span> searchText: <span class="pre code type">String</span> = <span class="pre code string">""</span>
  <span class="pre code keyword">@Published var</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>
  <span class="pre code keyword">@Published var</span> isSearching: <span class="pre code type">Bool</span> = <span class="pre code keyword">false

  var</span> showSearchCancelButton: <span class="pre code type">Bool</span> {
    <span class="pre code keyword">return</span> stateMachine.<span class="pre code property">state</span> == .<span class="pre code dotAccess">searching</span>
  }
  
  <span class="pre code keyword">init</span>(stateMachine: <span class="pre code type">StateMachine</span>) {
    <span class="pre code keyword">self</span>.<span class="pre code property">stateMachine</span> = stateMachine
    <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = stateMachine.<span class="pre code property">state</span>
    <span class="pre code keyword">self</span>.<span class="pre code property">stateCancellable</span> = stateMachine.<span class="pre code property">statePublisher</span>.<span class="pre code call">sink</span> { [<span class="pre code keyword">weak self</span>] state <span class="pre code keyword">in
	self</span>?.<span class="pre code property">state</span> = state
    }
  }
  
  <span class="pre code keyword">func</span> searchStatusChanged(<span class="pre code keyword">_</span> value: <span class="pre code type">SearchBar</span>.<span class="pre code type">Status</span>) {
    ...
  }
}
</code></pre><p>Note that the view model is acting as a middleware, propagating the changes from the state machine’s <code>state</code>, through it's own published property. We'll get back to why this is a good pattern.</p><p>With this view model we can add some state to our search bar:</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  ...    
  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        <span class="pre code type">SearchBar</span>(
          text: <span class="pre code property">$viewModel</span>.<span class="pre code property">searchText</span>,
          isEditing: <span class="pre code property">$viewModel</span>.<span class="pre code property">isSearching</span>,
          showsCancelButton: viewModel.<span class="pre code property">showSearchCancelButton</span>,
          searchingChanged: viewModel.<span class="pre code property">searchStatusChanged</span>
        )
        ...
      }
   }
}
</code></pre><p>This adds the following capabilities to the search bar:</p><ul><li>Binding to the view model’s <code>searchText</code>, so that the view model observes changes to the text.</li><li>Binding to the view model’s <code>isSearching</code>, so that the view model can control the focus/first responder status of the text field. This property is derived from the view model’s state.</li><li>Property <code>showSearchCancelButton</code> to decide if the cancel button should be shown. This property is also derived from the view model’s state.</li><li>Callback function/closure <code>searchStatusChanged</code> that lets the search bar notify the view model about events in the search field. When the search bar calls this function we will generate events and send to our state machine.</li></ul><p>We now have a pretty complete skeleton of how our search bar should interoperate with our state. This leaves the part of the UI that’s below the search bar, the part where the main content goes. Since this part of the UI changes so much from state to state, we’ve decided to let the different states correspond to different views. We can use the current state to decide which view to draw.</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  <span class="pre code keyword">@ObservedObject var</span> viewModel: <span class="pre code type">ContentViewModel</span>

  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        ...
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span>
        ...
      }
    }
  }

  <span class="pre code keyword">private var</span> content: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">switch</span> viewModel.<span class="pre code property">state</span> {
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">start</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">StartView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searching</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">SearchingView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">loading</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">LoadingView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searchResults</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">SearchResultsView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">error</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">ErrorView</span>())
    }
  }
}
</code></pre><p>We wrap all our views in the type eraser <code>AnyView</code> to obfuscate to the compiler that different view types are being rendered here.</p><p>This gives us the main skeleton of our application, and now we can take a look at how the state machine is implemented in detail.</p><h3>State machine</h3><p>In this sample application, we’ve not used a state machine library. We have implemented states and events as enum cases instead, for simplicity.</p><pre><code><span class="pre code keyword">class</span> StateMachine {
  <span class="pre code keyword">enum</span> State {
    <span class="pre code keyword">case</span> start, searching, loading, searchResults, error
  }
  <span class="pre code keyword">enum</span> Event {
    <span class="pre code keyword">case</span> startSearch, cancel, search, success, failure
  }

  <span class="pre code keyword">private(set) var</span> state: <span class="pre code type">State</span> {
    <span class="pre code keyword">didSet</span> { stateSubject.<span class="pre code call">send</span>(<span class="pre code keyword">self</span>.<span class="pre code property">state</span>) }
  }
  <span class="pre code keyword">private let</span> stateSubject: <span class="pre code type">PassthroughSubject</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;
  <span class="pre code keyword">let</span> statePublisher: <span class="pre code type">AnyPublisher</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;

  <span class="pre code keyword">init</span>(state: <span class="pre code type">State</span>) {
    <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = state
    <span class="pre code keyword">self</span>.<span class="pre code property">stateSubject</span> = <span class="pre code type">PassthroughSubject</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;()
    <span class="pre code keyword">self</span>.<span class="pre code property">statePublisher</span> = <span class="pre code keyword">self</span>.<span class="pre code property">stateSubject</span>.<span class="pre code call">eraseToAnyPublisher</span>()
  }
}
</code></pre><p>The machine stores the current state in a variable that is read-only, and offers a publisher that notifies any listeners every time the state is changed internally. To let the machine respond to events we will add a function that takes an event and may change the state of the state machine.</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">StateMachine</span> {
  <span class="pre code keyword">func</span> tryEvent(<span class="pre code keyword">_</span> event: <span class="pre code type">Event</span>) {
    <span class="pre code keyword">if let</span> state = <span class="pre code call">nextState</span>(for: event) {
      <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = state
    }
  }
}
</code></pre><p>By using switch statements we can let the compiler help us know that we’ve covered all the possible combinations of states and events.</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">StateMachine</span> {
  <span class="pre code keyword">private func</span> nextState(for event: <span class="pre code type">Event</span>) -&gt; <span class="pre code type">State</span>? {
    <span class="pre code keyword">switch</span> state {
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">start</span>:
      <span class="pre code keyword">switch</span> event {
      <span class="pre code keyword">case</span> .<span class="pre code dotAccess">startSearch</span>: <span class="pre code keyword">return</span> .<span class="pre code dotAccess">searching</span>
      <span class="pre code keyword">case</span> .<span class="pre code dotAccess">cancel</span>, .<span class="pre code dotAccess">search</span>, .<span class="pre code dotAccess">success</span>, .<span class="pre code dotAccess">failure</span>: <span class="pre code keyword">return nil</span>
      }
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searching</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">loading</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searchResults</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">error</span>: ...
    }
  }
}
</code></pre><p>With this implementation, we can get a pretty good overview of how the machine works. It’s also pretty easy to step through this function using the debugger if we’re unsure about some state transitions. The main downside of this type of notation is that it can become pretty verbose when the number of states/events increase. It’s pretty manageable in this case, but we would consider a library or some other implementation of the state transitions that will allow for more ergonomic code if needed.</p><h3>Side effects</h3><p>We mentioned earlier that the view model acts as a middleware between the state machine and the view when it comes to observing state. One of the reasons that we’ve chosen to do this is to enable our state changes to have side effects. State machines very often have side effects when either entering or leaving states. To enable this we will add property observers (<code>willSet</code> and <code>didSet</code>) to the view model's <code>state</code> variable and some functions to handle the transitions:</p><pre><code><span class="pre code keyword">class</span> ContentViewModel {
  ...
  <span class="pre code keyword">@Published var</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span> {
    <span class="pre code keyword">willSet</span> { <span class="pre code call">leaveState</span>(state) }
    <span class="pre code keyword">didSet</span> { <span class="pre code call">enterState</span>(state) }
  }  
  ...
  <span class="pre code keyword">func</span> leaveState(<span class="pre code keyword">_</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>) {
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">searching</span> = state {
      isSearching = <span class="pre code keyword">false</span>
    }
  }
  <span class="pre code keyword">func</span> enterState(<span class="pre code keyword">_</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>) {
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">searching</span> = state {
      isSearching = <span class="pre code keyword">true</span>
    }
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">loading</span> = state {
      <span class="pre code call">search</span>()
    }
  }
}
</code></pre><p>We set the <code>isSearching</code> property when entering or leaving the searching state. With the help of Combine and SwiftUI this propagates all the way into the <code>SearchBar</code> component and makes the keyboard appear and disappear. Additionally, we also let entering the loading state trigger our network request. In this application we are helped a lot by SwiftUI, Combine and the <code>@ObservedObject</code> property wrapper in the <code>ContentView</code>. By using this property wrapper we get UI changes for free whenever the state of our view model changes. If we had a more traditional UIKit application we would use these state transition functions to also swap out the visible view of our application. The main idea behind this architecture is to let the state machine drive UI changes, and so it’s an essential part to let the machine have side effects.</p><h2>Wrapping up</h2><p>We’ve seen how a state machine can help us structure and validate code, and how it helps us get an overview of an application’s flow. This sample application is pretty simple, but it is heavily inspired by a (more complicated) real-world implementation that we’ve worked on for a client. We think it illustrates the point of how a state machine will help us structure code. Adding a state machine may not let you write any less code — or less complicated code for that matter — but we do believe that it helps structure code more to a more understandable format. It helps us gather the logic that has to do with flow and transitions in a centralized place, and it lets us respond to changes in state in a well defined and structured way.</p><p>The state machine can also help us if we need to add something or make changes to the way our application works. Since all logic is centralised, we can easily see what effects a particular change will have on our application. Many times we can also get compiler support, for instance by using enum cases as states or events, so that we are sure we haven’t left some combination of state and events unimplemented.</p><p>If you want to see the complete implementation of this app you can check out the <a href="https://github.com/peterringset/StateMachineUI">GitHub repository</a>. You can also <a href="https://twitter.com/PRingset">follow me on twitter</a>, where I post links to articles that I’m writing.</p><img src="https://raw.githubusercontent.com/peterringset/StateMachineUI/master/demo/demo.gif" alt="Demo"/>]]></content:encoded></item></channel></rss>