<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Peter Ringset</title><description>My name is Peter, and I'm an iOS developer. On this blog I'll share my thoughts on various subjects in iOS development, and tips and tricks around developing apps for the Apple ecosystem.</description><link>https://peterringset.dev</link><language>en</language><lastBuildDate>Tue, 7 Mar 2023 20:03:17 +0100</lastBuildDate><pubDate>Tue, 7 Mar 2023 20:03:17 +0100</pubDate><ttl>250</ttl><atom:link href="https://peterringset.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://peterringset.dev/articles/column-breakpoints</guid><title>Making breakpoints work with single-line code blocks</title><description>Did you know you can make the Xcode debugger break on single line code blocks?</description><link>https://peterringset.dev/articles/column-breakpoints</link><pubDate>Tue, 7 Mar 2023 19:39:00 +0100</pubDate><content:encoded><![CDATA[<p>When writing functional code we often run into situations where there are a lot of nested function calls. In many cases we want to compact the code, so that each function call is a single line. Take for instance this example, working with a combine publisher:</p><pre><code><span class="pre code keyword">func</span> observeName() {
    service.<span class="pre code call">namePublisher</span>()
        .<span class="pre code call">map</span> { $0.<span class="pre code property">name</span> }
        .<span class="pre code call">filter</span> { $0.<span class="pre code property">name</span>.<span class="pre code call">contains</span>(<span class="pre code string">"something"</span>) }
        .<span class="pre code call">eraseToAnyPublisher</span>()
}
</code></pre><p>When this code executes a breakpoint at any line here will only break once the function is called, and the publisher is set up. If you want to also the debugger to break whenever the <code>map</code> function is called you normally will have to reformat your code so that the <code>$0.name</code> statement falls on a separate line, and you can unambiguously tell the debugger that it's right there you want to break.</p><pre><code><span class="pre code keyword">func</span> observeName() {
    service.<span class="pre code call">namePublisher</span>()
        .<span class="pre code call">map</span> {
            $0.<span class="pre code property">name</span>  <span class="pre code comment">// breakpoint here</span>
        }
        .<span class="pre code call">filter</span> { $0.<span class="pre code property">name</span>.<span class="pre code call">contains</span>(<span class="pre code string">"something"</span>) }
        .<span class="pre code call">eraseToAnyPublisher</span>()
}
</code></pre><p>This is far from ideal. Most importantly this forces you to actually stop your running app instance, and recompile with these code change for the debugger to start breaking inside the block. Secondly, this also leaves small code changes all over your code base, which you will have to come back and fix once you're done debugging.</p><p>There is, however a far better solution; column breakpoints. Column breakpoints are just like regular breakpoints, but you can enable them on nested blocks of code. To create one you simply right click at the statement you want to break on, and click <code>Create column breakpoint</code>. This creates a breakpoint at the beginning of the selected statement, and this breakpoint works just as a normal breakpoint does. You can right click it to pull up the context menu, double click to edit, or drag away to delete.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/light-and-dark-preview</guid><title>Previewing SwiftUI views in both dark and light mode</title><description>See how you can easily get both dark and light mode previews in SwiftUI</description><link>https://peterringset.dev/articles/light-and-dark-preview</link><pubDate>Fri, 22 Apr 2022 20:16:00 +0200</pubDate><content:encoded><![CDATA[<p>The light and dark mode feature in iOS was a very welcome addition when it was first introduced. These days it's more or less expected that a high-quality app has a good implementation of both light and dark color schemes. The iOS frameworks have very good support for implementing this, so this post won't go into any details there. Instead, we'll take a look at how you can easily preview both cases (and any potential future cases) using a very simple view struct in SwiftUI.</p><p>The first thing to note is how to force the system to use one of the color schemes. The old (and now deprecated) way is by using the view modifier</p><pre><code><span class="pre code keyword">@inlinable public func</span> colorScheme(<span class="pre code keyword">_</span> colorScheme: <span class="pre code type">ColorScheme</span>) -&gt; <span class="pre code keyword">some</span> <span class="pre code type">View</span>
</code></pre><p>This view modifier also has a key problem, it changes the color scheme of the entire screen, not only the view it is applied to. This can lead to some undefined situations if several views in the view hierarchy use this modifier at the same time.</p><p>Instead, we'll use the new view modifier</p><pre><code><span class="pre code keyword">@inlinable public func</span> preferredColorScheme(<span class="pre code keyword">_</span> colorScheme: <span class="pre code type">ColorScheme</span>?) -&gt; <span class="pre code keyword">some</span> <span class="pre code type">View</span>
</code></pre><p>To make this even more useful we'll create a reusable <code>View</code> component that can be used across our app to preview views we create in all possible color schemes. We can use the view builder functionality that SwiftUI is built on so that the call site can supply more than one view, and do it with the same syntax that the views are built. The <code>ColorScheme</code> enum that specifies the active scheme implements the <code>CaseIterable</code> protocol, making it very easy for us to iterate over all cases in the enum. Putting this all together we can get the following <code>View</code> type:</p><pre><code><span class="pre code keyword">struct</span> ColorSchemesPreview&lt;Content: <span class="pre code type">View</span>&gt;: <span class="pre code type">View</span> {
    <span class="pre code keyword">let</span> content: <span class="pre code type">Content</span>

    <span class="pre code keyword">init</span>(<span class="pre code keyword">@ViewBuilder</span> content: () -&gt; <span class="pre code type">Content</span>) {
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span> = <span class="pre code call">content</span>()
    }

    <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        <span class="pre code type">ForEach</span>(<span class="pre code type">ColorScheme</span>.<span class="pre code property">allCases</span>, id: \.<span class="pre code keyword">self</span>) { colorScheme <span class="pre code keyword">in</span>
            content.<span class="pre code call">preferredColorScheme</span>(colorScheme)
        }
    }
}
</code></pre><p>We can also set up a simple preview to demonstrate how this component works:</p><pre><code><span class="pre code keyword">struct</span> ColorSchemesPreview_Previews: <span class="pre code type">PreviewProvider</span> {
    <span class="pre code keyword">static var</span> previews: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        <span class="pre code type">ColorSchemesPreview</span> {
            <span class="pre code type">Text</span>(<span class="pre code string">"Hello"</span>)
            <span class="pre code type">Text</span>(<span class="pre code string">"world!"</span>)
        }
        .<span class="pre code call">padding</span>()
        .<span class="pre code call">previewLayout</span>(.<span class="pre code dotAccess">sizeThatFits</span>)
    }
}
</code></pre><p>Note how we're using both <code>padding()</code> and <code>previewLayout(.sizeThatFits)</code> directly on the <code>ColorSchemesPreview</code> type. This works so well because of the view builder mechanism, allowing us to specify views like we would in a system-provided SwiftUI component.</p><h2>One step further</h2><p>We can also expand on this by using view modifiers. The view modifier can be set up using the same mechanism as the preview View:</p><pre><code><span class="pre code keyword">struct</span> ColorSchemesViewModifier: <span class="pre code type">ViewModifier</span> {
    <span class="pre code keyword">func</span> body(content: <span class="pre code type">Content</span>) -&gt; <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        <span class="pre code type">Group</span> {
            <span class="pre code type">ForEach</span>(<span class="pre code type">ColorScheme</span>.<span class="pre code property">allCases</span>, id: \.<span class="pre code keyword">self</span>) { colorScheme <span class="pre code keyword">in</span>
                content.<span class="pre code call">preferredColorScheme</span>(colorScheme)
            }
        }
    }
}
</code></pre><p>We'll add an extension on <code>View</code> to allow for easy use.</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">func</span> colorSchemesPreview() -&gt; <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        <span class="pre code keyword">self</span>.<span class="pre code call">modifier</span>(<span class="pre code type">ColorSchemesViewModifier</span>())
    }
}
</code></pre><p>Then we can change the view to use the view modifier instead:</p><pre><code><span class="pre code keyword">struct</span> ColorSchemesPreview&lt;Content: <span class="pre code type">View</span>&gt;: <span class="pre code type">View</span> {
    <span class="pre code keyword">let</span> content: <span class="pre code type">Content</span>
    
    <span class="pre code keyword">init</span>(<span class="pre code keyword">@ViewBuilder</span> content: () -&gt; <span class="pre code type">Content</span>) {
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span> = <span class="pre code call">content</span>()
    }
    
    <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        content.<span class="pre code call">colorSchemesPreview</span>()
    }
}
</code></pre><p>Finally, we'll update our preview code to show off how to use the view modifier:</p><pre><code><span class="pre code keyword">struct</span> ColorSchemesPreview_Previews: <span class="pre code type">PreviewProvider</span> {
    <span class="pre code keyword">static var</span> previews: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
        <span class="pre code type">Group</span> {
            <span class="pre code type">Text</span>(<span class="pre code string">"Hello"</span>)
            <span class="pre code type">Text</span>(<span class="pre code string">"world!"</span>)
        }
        .<span class="pre code call">padding</span>()
        .<span class="pre code call">previewLayout</span>(.<span class="pre code dotAccess">sizeThatFits</span>)
        .<span class="pre code call">colorSchemesPreview</span>()
    }
}
</code></pre><p>Happy previewing! ✌️</p>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/namespaced-colors</guid><title>Creating namespaces for named colors in Xcode</title><description>Did you know that you can namespace your colors in asset catalogs?</description><link>https://peterringset.dev/articles/namespaced-colors</link><pubDate>Fri, 26 Nov 2021 16:02:00 +0100</pubDate><content:encoded><![CDATA[<p>Xcode's feature for named colors has been around for a few years now. When it first was introduced it was a big improvement on the existing system for vending colors, but one of the major drawbacks that were never addressed is the problem of naming safety. The current initializer takes the name as a <code>String</code>, which leads to a couple of problems. The most obvious one is that it is prone to typos, but perhaps more importantly, it does not guarantee that the name will actually resolve to a <code>UIColor</code> instance in the future if for instance the color is renamed.</p><h2>#colorLiteral</h2><p>Xcode does have a built-in mechanism for working with color literals, namely the <code>#colorLiteral(red:green:blue:alpha:)</code> statement, but unfortunately this suffers from a major drawback. The color literal only refers to the RGBA values and not the name of the color. This means that the literal will stay unchanged if the source color changes. The color literals will also be hard to use in apps that support both dark and light modes.</p><p>This leads us to think that we need to find a better way for structuring and naming colors in apps that use named colors and asset catalogs.</p><h2>Design systems</h2><p>Another motivation for structuring and naming our color use is when working with design systems. Most designers worth their salt will have a clearly defined color palette – not only for the primary, secondary, text, and similar colors but also hairline borders, shadows, and similar. This means that there will be at least a handful of colors to work with, and structuring our color system is starting to make more and more sense.</p><h2>First stab – <code>static</code> properties</h2><p>Usually, this results in developers declaring their colors in some way, for instance as an extension on <code>UIColor</code>:</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static var</span> brandMain: <span class="pre code type">UIColor</span> { <span class="pre code type">UIColor</span>(named: <span class="pre code string">"brandMain"</span>)! }
    <span class="pre code keyword">static var</span> brandSecondary: <span class="pre code type">UIColor</span> { <span class="pre code type">UIColor</span>(named: <span class="pre code string">"brandSecondary"</span>)! }
}
</code></pre><p>This solution is quite a bit better, but there is still room for improvement. The name of the color is written twice, or three times actually, if we count the name in the asset catalog as well.</p><h2>Second stab – <code>enum</code>-backed initialization</h2><p>To get ease the work of declaring things multiple times, and help implement changes and additions to our color palette we can use <code>String</code>-backed <code>enum</code>s to name our colors.</p><pre><code><span class="pre code keyword">enum</span> BrandColor: <span class="pre code type">String</span> {
    <span class="pre code keyword">case</span> main, secondary, text
}

<span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static func</span> brand(<span class="pre code keyword">_</span> name: <span class="pre code type">BrandColor</span>) -&gt; <span class="pre code type">UIColor</span> {
        <span class="pre code keyword">guard let</span> color = <span class="pre code type">UIColor</span>(named: name.<span class="pre code property">rawValue</span>) <span class="pre code keyword">else</span> {
            <span class="pre code call">fatalError</span>(<span class="pre code string">"Failed to load named color"</span>)
        }
        <span class="pre code keyword">return</span> color
    }
}
</code></pre><p>To be even more thorough we can also use the more complicated initializer</p><pre><code><span class="pre code type">UIColor</span>(named: name.<span class="pre code property">rawValue</span>, in: <span class="pre code type">Bundle</span>(for: <span class="pre code type">PrivateClass</span>.<span class="pre code keyword">self</span>), compatibleWith: <span class="pre code keyword">nil</span>)
</code></pre><p>with an empty class named <code>PrivateClass</code> (or any other class that belongs to the same bundle) to be able to use these colors outside of our bundle.</p><p>This leaves us with a pretty solid solution for handling colors in our app. This can be more than enough for a lot of apps. But, sometimes we can run into situations where we have a very large number of colors to handle. For instance, there could be the main palette, containing three or four colors used to color UI elements. Then there could be a second palette to handle text, maybe three or four colors there as well. Additionally, we could have a third palette for data visualizations, like cake diagrams and similar. This could add another six or seven colors. To add to this complexity, we will in many cases also run into situations where a text color is almost the same as a UI element color, only slightly darker. And this is what motivates our final improvement.</p><h2>Third stab - Namespaces</h2><p>A well-known feature in asset catalogs is to use folders to organize the assets. The folders are not actually folders though, they only help with grouping. Each asset's name still has to be unique to avoid naming collisions. But there is a more obscure feature we can also use – folders can actually provide namespaces. To enable this we'll have to select the folder in the left list and tick the <code>Provides Namespace</code> box at the top-right menu of the screen.</p><img src="https://peterringset.dev/images/namespaced-colors/provides-namespace.png" alt="Asset catalog"/><p>Our color names will now be <code>main/green</code>, <code>main/purple</code>, and <code>main/red</code>, which means that we can have multiple colors named <code>red</code>, just organized into different namespaces.</p><p>To support this new feature in code we will expand on our color instantiation a bit.</p><pre><code><span class="pre code keyword">struct</span> ColorNamespace&lt;C: <span class="pre code type">RawRepresentable</span>&gt; {
    <span class="pre code keyword">private let</span> colorType: <span class="pre code type">C</span>.<span class="pre code type">Type</span>? = <span class="pre code keyword">nil</span>
}

<span class="pre code keyword">extension</span> <span class="pre code type">UIColor</span> {
    <span class="pre code keyword">static func</span> named&lt;C: <span class="pre code type">NamespacedColor</span>&gt;(<span class="pre code keyword">_</span> namespace: <span class="pre code type">ColorNamespace</span>&lt;<span class="pre code type">C</span>&gt;, color: <span class="pre code type">C</span>) -&gt; <span class="pre code type">UIColor</span> {
        <span class="pre code keyword">return</span> <span class="pre code type">UIColor</span>(named: <span class="pre code string">"</span>\(<span class="pre code type">C</span>.<span class="pre code property">namespace</span>)<span class="pre code string">/</span>\(color.<span class="pre code property">rawValue</span>)<span class="pre code string">"</span>)!
    }
}
</code></pre><p>Then we declare our different namespaces</p><pre><code><span class="pre code keyword">protocol</span> NamespacedColor: <span class="pre code type">RawRepresentable</span> <span class="pre code keyword">where</span> <span class="pre code type">RawValue</span> == <span class="pre code type">String</span> {
    <span class="pre code keyword">static var</span> namespace: <span class="pre code type">String</span> { <span class="pre code keyword">get</span> }
}

<span class="pre code keyword">enum</span> MainColors: <span class="pre code type">String</span>, <span class="pre code type">NamespacedColor</span> {
    <span class="pre code keyword">static var</span> namespace: <span class="pre code type">String</span> { <span class="pre code string">"main"</span> }
    <span class="pre code keyword">case</span> red, green, blue
}

<span class="pre code keyword">enum</span> SecondaryColors: <span class="pre code type">String</span>, <span class="pre code type">NamespacedColor</span> {
    <span class="pre code keyword">static var</span> namespace: <span class="pre code type">String</span> { <span class="pre code string">"secondary"</span> }
    <span class="pre code keyword">case</span> purple, yellow, orange
}
</code></pre><p>set up some short-hands to create namespaces</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">ColorNamespace</span> {
    <span class="pre code keyword">static var</span> main: <span class="pre code type">ColorNamespace</span>&lt;<span class="pre code type">MainColors</span>&gt; { <span class="pre code keyword">return</span> <span class="pre code type">ColorNamespace</span>&lt;<span class="pre code type">MainColors</span>&gt;() }
    <span class="pre code keyword">static var</span> secondary: <span class="pre code type">ColorNamespace</span>&lt;<span class="pre code type">SecondaryColors</span>&gt; { <span class="pre code keyword">return</span> <span class="pre code type">ColorNamespace</span>&lt;<span class="pre code type">SecondaryColors</span>&gt;() }
}
</code></pre><p>and instantiate our colors using</p><pre><code><span class="pre code keyword">let</span> mainRed: <span class="pre code type">UIColor</span> = .<span class="pre code call">named</span>(.<span class="pre code dotAccess">main</span>, color: .<span class="pre code dotAccess">red</span>)
<span class="pre code keyword">let</span> secondaryPurple: <span class="pre code type">UIColor</span> = .<span class="pre code call">named</span>(.<span class="pre code dotAccess">secondary</span>, color: .<span class="pre code dotAccess">purple</span>)
</code></pre><p>This lets us declare our colors in a structured way in our asset catalogs and write very small amounts of code to let us have a compile-safe instantiation of our colors.</p><h2>Bonus round – Tests</h2><p>To add a final layer of safety we can also add tests to make sure that all our color code resolves to actual colors. To do this we will use the <code>CaseIterable</code> protocol, and make each color enum conform to it. This allows us to iterate over all cases and check that they instantiate correctly.</p><pre><code><span class="pre code keyword">func</span> testMainColors() <span class="pre code keyword">throws</span> {
    <span class="pre code keyword">for</span> color <span class="pre code keyword">in</span> <span class="pre code type">MainColors</span>.<span class="pre code property">allCases</span> {
        <span class="pre code call">XCTAssertNotNil</span>(<span class="pre code type">UIColor</span>.<span class="pre code call">named</span>(.<span class="pre code dotAccess">main</span>, color: color))
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/live-reloads-for-publish</guid><title>Live reloads for Publish</title><description>See how to get live reloads when developing/writing with Publish</description><link>https://peterringset.dev/articles/live-reloads-for-publish</link><pubDate>Tue, 19 Oct 2021 19:53:00 +0200</pubDate><content:encoded><![CDATA[<p><a href="https://github.com/JohnSundell/Publish "Publish"">Publish</a> is a great tool to use when writing your own blog – I used it to write this blog. I think Publish is really great, and I love being able to use Swift for my blog posts. But when I was starting up, setting up my own blog, I really missed the possibility of using live reloads. I'm sure this is probably something that will come eventually be baked into the <code>publish</code> CLI, but at the time of writing it is not included.</p><p>When running the local webserver with <code>publish run</code> you still have to go into the browser and manually reload the page each time you've rebuilt the output directory (⌘+R). But there are a lot of ways you can solve this. A colleague of mine, who is a proficient web developer, tipped me on a node package called <a href="https://www.npmjs.com/package/live-server "live-server node package""><code>live-server</code></a>. It does exactly what you expect it to do. To run it you first have to make sure you have <a href="https://nodejs.org/en/ "Node.js"">Node</a> installed. Then you'll have to run</p><pre><code>cd <span class="pre code type">Output</span>
npx live-server
</code></pre><p>from the root of your publish project, and that's it. There's no dependency added to you project, just a simple one-liner to get your web-server up and running. If you're curious to how this actually works you can inspect the resulting html to see that it injects some javascript at the end of the html <code>&lt;body&gt;</code>, which sets up a socket to a locally running web server.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/passwordless-app-review</guid><title>Getting Your iOS App with Passwordless Sign in Approved by App Review</title><description>See how you can set up a simple system to get an app using passwordless sign in approved by app review.</description><link>https://peterringset.dev/articles/passwordless-app-review</link><pubDate>Fri, 15 Jan 2021 13:22:00 +0100</pubDate><content:encoded><![CDATA[<p>Apple’s app review will often require you to provide <a href="https://developer.apple.com/app-store/review/guidelines/#before-you-submit">login credentials</a> to a test account so that the reviewers can access all features in your app. Lately, the so-called passwordless type of login has become more and more common, especially since Apple has started catering more for auto-filling one time passwords (OTPs) sent via SMS. This can, however, lead to some headaches when submitting your app for review, and in the worst case may lead your submission to be rejected. This article will describe making a web app that can let Apple reviewers log in to your app using a passwordless SMS setup. We will use <a href="https://www.twilio.com">Twilio</a> as our SMS provider, and implement our app with <a href="https://vapor.codes">Vapor</a> and deploy it to <a href="https://dashboard.heroku.com">Heroku</a>.</p><p>If you’re mainly interested in trying this out for yourself you can head over to the <a href="https://github.com/peterringset/passwordless-login">GitHub repository</a>, where you will find what you need to get quickly up and running.</p><h2>Prerequisites</h2><p>This article is based on using Twilio for sending out SMS OTPs, but you can probably make some adjustments to make this work with almost any SMS service. This article will not cover any of the initial setup for the passwordless login, there are plenty of other guides for that out there. From this point on we will assume that your app has a working login mechanism that somehow uses Twilio for sending out OTPs.</p><p>The main idea behind this solution is to leave as much as possible of your existing application and infrastructure untouched. It is always risky to introduce special cases and backdoors into your application, and so we’re striving to leave all the application code completely untouched when allowing Apple’s reviewers to log in to a test account. To achieve this we require that there is a phone number that reviewers can log in with. You can try to purchase a number with Twilio, or you can use your own, it really doesn’t matter as long as it’s a phone number that you can try to send a message to.</p><p>We will instruct the reviewers to log in to your app normally, inputting the provided phone number and then being led to a screen where they’re supposed to input the OTP sent by SMS. At this point, you’re probably wondering how to make sure that the reviewers can log in with a valid OTP. In most applications, this OTP is a randomly generated number and is only valid for a couple of minutes, so that means that we’re reliant on using some sort of automated mechanism for providing this OTP to the reviewers.</p><h2>The Broad Strokes</h2><p>We’re basing our solution on <a href="https://www.twilio.com/docs/sms/tutorials/how-to-retrieve-and-modify-message-history">Twilio’s message history API</a>. This API lets us query what has been sent (or tried to be sent) from the message service we’ve set up. For our needs, we can query this API and get back the latest message sent to a specific number and display that on a website. This means that there are no special cases in our app or backend code to handle the login to the test account, everything works as normal. The only thing needed to make this setup work is a small web-application that can fetch the message containing the OTP and display it on a website.</p><h2>The Web App</h2><p>Twilio’s message history API has SDKs for many different languages, but since this is an article written mainly for Swift developers I’ve decided to write this web app in Swift, using <a href="https://vapor.codes">Vapor</a> as the server-side framework. If you haven’t used Vapor before I suggest you go to their website and <a href="https://docs.vapor.codes/4.0/install/macos/">install Vapor</a> before you come back here and read on.</p><p>To get started we will first create the skeleton of our Vapor application:</p><pre><code>vapor new passwordless-login --no-fluent --leaf
</code></pre><p>This sets up a brand new Vapor server application that uses Leaf (Vapor’s templating language). Open the <code>Package.swift</code> file with Xcode to get started adding functionality to our app.</p><p>To begin with, we will add a file to make sure that the project compiles on Linux.</p><pre><code>cd passwordless-login/  
touch <span class="pre code type">Tests</span>/<span class="pre code type">LinuxMain</span>.<span class="pre code property">swift</span>  
git commit --amend --no-edit
</code></pre><h2>Getting Data from Twilio</h2><p>Messages from Twilio comes to us as JSON, and we need to create a model for this. Put this file in <code>Sources/App/Models/Message.swift</code></p><p>Then we’ll implement a networking client that can fetch data from Twilio. To match the recommended structure of a Vapor project we’ll use the protocol name <code>TwilioRepository</code>, and make an implementation <code>TwilioAPIRepository</code> that fetches messages over the network. This file is put in <code>Sources/App/Repositories/TwilioRepository.swift</code>. We will start by adding a skeleton of the repository.</p><p>This skeleton sets up the URI with query parameters that ensure we only get one message for the specified phone number. It also specifies the <code>Authorization</code> header so we can authenticate with the Twilio API. Now we can modify the <code>latestMessage()</code> function to make the network call and deserialize the response into our <code>Message</code> type.</p><p>We also need to create a file for the type <code>TwilioConfig</code>. Put this file together with the message model, in <code>Sources/App/Models/TwilioConfig.swift</code></p><p>Note that we’re adding an extension to instantiate this struct from the environment since we don’t want to check in any identifiers, auth tokens or hard code any phone numbers.</p><p>Let’s commit these changes.</p><pre><code>git add .  
git commit -m <span class="pre code string">"Add repository for Twilio messages"</span>
</code></pre><p>With this in place, we can proceed to set up a simple page that displays this info.</p><h2>Setting up the Main Page</h2><p>Start by adding a file in <code>Sources/App/Controllers/MessageController.swift</code></p><p>This will render the Leaf file under <code>Resources/Views/index.leaf</code> with the provided data. Note that we're also filtering out the message if it's older than 120 seconds. In our case, this is the validity time of our OTP, but feel free to change this value if needed.</p><p>To wire up this route go to <code>Sources/App/routes.swift</code> and update the <code>routes</code> function.</p><p>We will also have to change <code>Sources/App/configure.swift</code> to pass the Twilio config.</p><p>Then head over to the <code>Resources/Views/index.leaf</code> file and replace its contents with the following:</p><p>You probably aren’t going to win any design awards with this page, but it gets the job done.</p><img src="https://peterringset.dev/images/passwordless-app-review/passwordless.png" alt="The web interface"/><p>To wrap up this step we will commit all our changes.</p><pre><code>git add .  
git commit -m <span class="pre code string">"Add controller and route for fetching latest message"</span>
</code></pre><h2>Authentication</h2><p>We want to protect this web page with authentication. We can make sure that the web page is only live we have a version in review and make sure that it’s only used for test accounts. But ultimately, it’s still a security issue and we should password protect the site to be as secure as we can.</p><p>Vapor has some built-in support for basic authentication, but unfortunately, they have not implemented the part that triggers the username/password prompt in web browsers, so we will roll our own implementation of this. Our implementation is heavily based on <a href="https://github.com/vapor/vapor/issues/2337#issuecomment-740675655">this answer on their GitHub issue</a>.</p><p>We won’t bother with a database or anything like that, since there’s only going to be one set of credentials for this site. So we will be using environment variables for this too. Create a new file in <code>Sources/App/Models/BasicAuthConfig.swift</code>:</p><p>To set up the basic auth itself we will add a new file <code>Sources/App/Middleware/UserAuthentication.swift</code>, and add the following code.</p><p>This actually doesn’t to any authentication yet, this first version only adds a user object to the request object before it is delivered to our controller. To make sure that the authentication is handled correctly we will change the <code>respond(to:chainingTo:)</code>function to do the following:</p><p>To make use of this we will have to modify our routing, change the <code>routes</code> function in <code>Sources/App/routes.swift</code>.</p><p>This will make sure that the middleware adds the appropriate headers whenever a controller tries to access a route protected by authentication. We also use a <code>User.guardMiddleware()</code> that makes sure that there is a <code>User</code> object present in all requests coming to the routes protected by these authenticators.</p><p>Remember to modify the call to the <code>routes</code> function in the <code>Sources/App/configure.swift</code> file.</p><p>Then commit these changes to git.</p><pre><code>git add .  
git commit -m <span class="pre code string">"Add authentication to protect web page with basic auth login"</span>
</code></pre><h2>Running locally</h2><p>You probably want to do local build and run by now. Since we’re using environment variables you need to set those up before running the app. You can do this by adding a <code>.env</code>-file in the root of the repository with the following content.</p><pre><code><span class="pre code type">TWILIO_ACCOUNT_SID</span>=&lt;twilio-account-sid&gt;  
<span class="pre code type">TWILIO_AUTH_TOKEN</span>=&lt;twilio-auth-token&gt;  
<span class="pre code type">TWILIO_TO_NUMBER</span>=&lt;phone-number&gt;  
<span class="pre code type">BASIC_AUTH_REALM</span>=<span class="pre code type">Messages  
BASIC_AUTH_USERNAME</span>=&lt;username&gt;  
<span class="pre code type">BASIC_AUTH_PASSWORD</span>=&lt;password&gt;
</code></pre><p>Make sure to replace the bracketed values with real values for your setup. The identifier and token for Twilio can be found in <a href="https://www.twilio.com/console">their console</a>.</p><h2>Deploying to Heroku</h2><p>There are a few choices for deploying a Vapor application, one of the simplest is through <a href="https://dashboard.heroku.com">Heroku</a>. They have built-in support for running Vapor applications, so there are <a href="https://docs.vapor.codes/3.0/deploy/heroku/">very few steps</a> to get our little web app live. If you don’t have the Heroku CLI installed yet you can start by installing it via <a href="https://brew.sh">Homebrew</a>.</p><pre><code>brew install heroku/brew/heroku
</code></pre><p>Then make sure you are logged in with the CLI.</p><pre><code>heroku login
</code></pre><h3>Set up</h3><p>We need to create a <code>Procfile</code> that describes how to run our application to Heroku, and a <code>.swift-version</code> file that specifies our Swift version. At the time of writing the highest supported version of Swift on Heroku's servers is 5.3.</p><pre><code>echo <span class="pre code string">"web: Run --env production --hostname 0.0.0.0 --port $PORT"</span> &gt; <span class="pre code type">Procfile</span>  
echo <span class="pre code string">"5.3"</span> &gt; .<span class="pre code dotAccess">swift</span>-version
</code></pre><p>Heroku’s deployment process is based on pushing your code to a git remote that they control. Use the Heroku CLI to first create the app in the Heroku system, and then add the Heroku remote to our git repository.</p><pre><code>heroku apps:create &lt;your-application-name&gt; --buildpack vapor/vapor  
heroku git:remote -a &lt;your-application-name&gt;
</code></pre><p>Make sure to replace <code>&lt;your-application-name&gt;</code> with a real application name.</p><h3>Environment</h3><p>Since we’re using environment variables (or config vars in Heroku’s terms) in our application we need to make sure that they’re set up in Heroku’s system. We will do this by using the CLI:</p><pre><code>heroku config:<span class="pre code keyword">set</span> \  
 <span class="pre code type">TWILIO_ACCOUNT_SID</span>=&lt;twilio-account-sid&gt; \  
 <span class="pre code type">TWILIO_AUTH_TOKEN</span>=&lt;twilio-auth-token&gt; \  
 <span class="pre code type">TWILIO_TO_NUMBER</span>=&lt;phone-number&gt; \  
 <span class="pre code type">BASIC_AUTH_REALM</span>=<span class="pre code type">Messages</span> \  
 <span class="pre code type">BASIC_AUTH_USERNAME</span>=&lt;username&gt; \  
 <span class="pre code type">BASIC_AUTH_PASSWORD</span>=&lt;password&gt;
</code></pre><h3>Deploying</h3><p>To wrap everything up we will commit our changes and deploy to Heroku.</p><pre><code>git add .  
git commit -m <span class="pre code string">"Add Heroku build files"</span>  
git push heroku master
</code></pre><p>The deployment process is going to take a few minutes of building and getting everything ready.</p><p>If you need to start or stop your app you can run the following commands.</p><pre><code>heroku ps:scale web=<span class="pre code number">0</span> <span class="pre code comment">// stop</span>  
<span class="pre code type">Heroku</span> ps:scale web=<span class="pre code number">1</span> <span class="pre code comment">// start</span>
</code></pre><h2>Wrapping up</h2><p>And with that, you have a live and working web app that can help you get your app approved by app review. The final application lets us keep our app and backend code intact, without having to introduce any back doors or special cases to let reviewers log in. Apart from deploying this web app you also have to make sure that the reviewers can successfully log in using the provided phone number in your system.</p><p>To check out the final source code for this project you can go to the <a href="https://github.com/peterringset/passwordless-login">GitHub repository</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://peterringset.dev/articles/building-a-state-driven-app</guid><title>Building a state driven app in SwiftUI using state machines</title><description>See how to use state machines to build a simple image searching application in SwiftUI.</description><link>https://peterringset.dev/articles/building-a-state-driven-app</link><pubDate>Tue, 18 Feb 2020 14:03:00 +0100</pubDate><content:encoded><![CDATA[<p>When developers are working on complex features we often talk about state. Many times we don’t want to deal with state, at least when it’s mutable. State complicates everything, especially when it can change. In this post, we’re going to look at how to deal with state in UIs, specifically iOS applications, but the principles should translate to almost any platform.</p><p>I’ve recently written <a href="https://medium.com/eggs-design/let-designers-and-developers-collaborate-through-state-diagrams-48a1d9a484df	"Let designers and developers collaborate through state diagrams"">a blog post about state diagrams and collaboration</a> between designers and developers. We’ll be looking at the same sample application in this post. In this post, however, we’re taking a more technical perspective and will be looking at how we can use the state machine to drive UI changes and respond to events. The sample code is also <a href="https://github.com/peterringset/StateMachineUI">available on GitHub</a> if you want to check it out in more detail.</p><h2>Sample application</h2><p>The main concept of our sample application is a search function that can search for images on <a href="https://pixabay.com/service/about/api/">pixabay</a>. We already have a design spec for our application, it looks like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/screens.jpg" alt="Design specification"/><p>There are five different screens in this UI: the empty start screen, the searching screen, the loading screen, and finally the result screen or the failure screen. The way these screens are laid out in the canvas above tells us something about how they are related to each other. We can already infer quite a bit about the UX and flow of this application by just looking at this canvas. For instance, the transition from the start screen to the searching screen is triggered by the user tapping in the search field. Similarly, the transition from the searching screen to the loading screen is triggered by the user tapping the search button in the bottom right of the keyboard. We see that transitioning to the loading screen will also mean firing a network request to the pixabay API. Since we know that network requests are prone to fail, we also have a failure screen for when that inevitably happens.</p><p>But what should happen when the user has reached one of these two “end states” (error or results) and wants to search again? It’s not entirely clear from the sketches, and we see that there is room for a more complete specification here.</p><h2>State diagrams</h2><p>To specify our design spec further we are going to use a state diagram. Our notation here will be circled text to represent states, and arrows with text to represent transitions between states, like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/state_diagram_example.jpg" alt="A state diagram"/><p>Note that the text next to each arrow is typically an event or action. In this case, we’re dealing with UIs, so a typical action can be a button tap, text field selection, and also external events like a network request returning a result. The state diagram for our sample application looks like this:</p><img src="https://peterringset.dev/images/building-a-state-driven-app/state_diagram.jpg" alt="Our state diagram"/><p>We are defining some actions in our state diagram:</p><ul><li>Start search: the user taps the search text field to give it focus</li><li>Cancel: the user taps the cancel button that appears next to the text field</li><li>Search: the user taps the search button in the keyboard</li><li>Success: the network request to pixabay returned with results</li><li>Failure: the network request to pixabay failed</li></ul><p>This gives us a pretty complete picture of how this application is supposed to work, so now we can go over to implementation.</p><h2>Implementation</h2><p>Our sample application is implemented in SwiftUI, using the MVVM architecture. The structure of our application is a container view ( <code>ContentView</code>) that encapsulates our application window. This window has a corresponding view model that handles our logic and houses our state handling.</p><h3>The User interface</h3><p>The view hierarchy is pretty simple. Everything is wrapped in a <code>NavigationView</code>. The first view inside is a custom component, the <code>SearchBar</code> view, that wraps UIKit's <code>UISearchBar</code>. Below that is the main content of each screen, and that's going to vary with the state of our application.</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  <span class="pre code keyword">@ObservedObject var</span> viewModel: <span class="pre code type">ContentViewModel</span>
  
  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        <span class="pre code type">SearchBar</span>()
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span>
        <span class="pre code type">Spacer</span>()
      }
    }
  }
  
  <span class="pre code keyword">private var</span> content: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">switch</span> viewModel.<span class="pre code property">state</span> {
    ...
    }
  }
}
</code></pre><p>To implement our state diagram we’re using a state machine, that defines all the states and events (actions):</p><pre><code><span class="pre code keyword">class</span> StateMachine {
  <span class="pre code keyword">enum</span> State {
    <span class="pre code keyword">case</span> start, searching, loading, searchResults, error
  }
  <span class="pre code keyword">enum</span> Event {
    <span class="pre code keyword">case</span> startSearch, cancel, search, success, failure
  }
  ...
}
</code></pre><p>The state is going to influence both the search bar and the content below. The search bar can trigger events, and its appearance is dependent on the state. We start with the following view model:</p><pre><code><span class="pre code keyword">class</span> ContentViewModel: <span class="pre code type">ObservableObject</span> {
  <span class="pre code keyword">private let</span> stateMachine: <span class="pre code type">StateMachine</span>
  <span class="pre code keyword">private var</span> stateCancellable: <span class="pre code type">AnyCancellable</span>?

  <span class="pre code keyword">@Published var</span> searchText: <span class="pre code type">String</span> = <span class="pre code string">""</span>
  <span class="pre code keyword">@Published var</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>
  <span class="pre code keyword">@Published var</span> isSearching: <span class="pre code type">Bool</span> = <span class="pre code keyword">false

  var</span> showSearchCancelButton: <span class="pre code type">Bool</span> {
    <span class="pre code keyword">return</span> stateMachine.<span class="pre code property">state</span> == .<span class="pre code dotAccess">searching</span>
  }
  
  <span class="pre code keyword">init</span>(stateMachine: <span class="pre code type">StateMachine</span>) {
    <span class="pre code keyword">self</span>.<span class="pre code property">stateMachine</span> = stateMachine
    <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = stateMachine.<span class="pre code property">state</span>
    <span class="pre code keyword">self</span>.<span class="pre code property">stateCancellable</span> = stateMachine.<span class="pre code property">statePublisher</span>.<span class="pre code call">sink</span> { [<span class="pre code keyword">weak self</span>] state <span class="pre code keyword">in
	self</span>?.<span class="pre code property">state</span> = state
    }
  }
  
  <span class="pre code keyword">func</span> searchStatusChanged(<span class="pre code keyword">_</span> value: <span class="pre code type">SearchBar</span>.<span class="pre code type">Status</span>) {
    ...
  }
}
</code></pre><p>Note that the view model is acting as a middleware, propagating the changes from the state machine’s <code>state</code>, through it's own published property. We'll get back to why this is a good pattern.</p><p>With this view model we can add some state to our search bar:</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  ...    
  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        <span class="pre code type">SearchBar</span>(
          text: <span class="pre code property">$viewModel</span>.<span class="pre code property">searchText</span>,
          isEditing: <span class="pre code property">$viewModel</span>.<span class="pre code property">isSearching</span>,
          showsCancelButton: viewModel.<span class="pre code property">showSearchCancelButton</span>,
          searchingChanged: viewModel.<span class="pre code property">searchStatusChanged</span>
        )
        ...
      }
   }
}
</code></pre><p>This adds the following capabilities to the search bar:</p><ul><li>Binding to the view model’s <code>searchText</code>, so that the view model observes changes to the text.</li><li>Binding to the view model’s <code>isSearching</code>, so that the view model can control the focus/first responder status of the text field. This property is derived from the view model’s state.</li><li>Property <code>showSearchCancelButton</code> to decide if the cancel button should be shown. This property is also derived from the view model’s state.</li><li>Callback function/closure <code>searchStatusChanged</code> that lets the search bar notify the view model about events in the search field. When the search bar calls this function we will generate events and send to our state machine.</li></ul><p>We now have a pretty complete skeleton of how our search bar should interoperate with our state. This leaves the part of the UI that’s below the search bar, the part where the main content goes. Since this part of the UI changes so much from state to state, we’ve decided to let the different states correspond to different views. We can use the current state to decide which view to draw.</p><pre><code><span class="pre code keyword">struct</span> ContentView: <span class="pre code type">View</span> {
  <span class="pre code keyword">@ObservedObject var</span> viewModel: <span class="pre code type">ContentViewModel</span>

  <span class="pre code keyword">var</span> body: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">return</span> <span class="pre code type">NavigationView</span> {
      <span class="pre code type">VStack</span>(spacing: <span class="pre code number">0</span>) {
        ...
        <span class="pre code keyword">self</span>.<span class="pre code property">content</span>
        ...
      }
    }
  }

  <span class="pre code keyword">private var</span> content: <span class="pre code keyword">some</span> <span class="pre code type">View</span> {
    <span class="pre code keyword">switch</span> viewModel.<span class="pre code property">state</span> {
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">start</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">StartView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searching</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">SearchingView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">loading</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">LoadingView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searchResults</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">SearchResultsView</span>())
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">error</span>: <span class="pre code keyword">return</span> <span class="pre code type">AnyView</span>(<span class="pre code type">ErrorView</span>())
    }
  }
}
</code></pre><p>We wrap all our views in the type eraser <code>AnyView</code> to obfuscate to the compiler that different view types are being rendered here.</p><p>This gives us the main skeleton of our application, and now we can take a look at how the state machine is implemented in detail.</p><h3>State machine</h3><p>In this sample application, we’ve not used a state machine library. We have implemented states and events as enum cases instead, for simplicity.</p><pre><code><span class="pre code keyword">class</span> StateMachine {
  <span class="pre code keyword">enum</span> State {
    <span class="pre code keyword">case</span> start, searching, loading, searchResults, error
  }
  <span class="pre code keyword">enum</span> Event {
    <span class="pre code keyword">case</span> startSearch, cancel, search, success, failure
  }

  <span class="pre code keyword">private(set) var</span> state: <span class="pre code type">State</span> {
    <span class="pre code keyword">didSet</span> { stateSubject.<span class="pre code call">send</span>(<span class="pre code keyword">self</span>.<span class="pre code property">state</span>) }
  }
  <span class="pre code keyword">private let</span> stateSubject: <span class="pre code type">PassthroughSubject</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;
  <span class="pre code keyword">let</span> statePublisher: <span class="pre code type">AnyPublisher</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;

  <span class="pre code keyword">init</span>(state: <span class="pre code type">State</span>) {
    <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = state
    <span class="pre code keyword">self</span>.<span class="pre code property">stateSubject</span> = <span class="pre code type">PassthroughSubject</span>&lt;<span class="pre code type">State</span>, <span class="pre code type">Never</span>&gt;()
    <span class="pre code keyword">self</span>.<span class="pre code property">statePublisher</span> = <span class="pre code keyword">self</span>.<span class="pre code property">stateSubject</span>.<span class="pre code call">eraseToAnyPublisher</span>()
  }
}
</code></pre><p>The machine stores the current state in a variable that is read-only, and offers a publisher that notifies any listeners every time the state is changed internally. To let the machine respond to events we will add a function that takes an event and may change the state of the state machine.</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">StateMachine</span> {
  <span class="pre code keyword">func</span> tryEvent(<span class="pre code keyword">_</span> event: <span class="pre code type">Event</span>) {
    <span class="pre code keyword">if let</span> state = <span class="pre code call">nextState</span>(for: event) {
      <span class="pre code keyword">self</span>.<span class="pre code property">state</span> = state
    }
  }
}
</code></pre><p>By using switch statements we can let the compiler help us know that we’ve covered all the possible combinations of states and events.</p><pre><code><span class="pre code keyword">extension</span> <span class="pre code type">StateMachine</span> {
  <span class="pre code keyword">private func</span> nextState(for event: <span class="pre code type">Event</span>) -&gt; <span class="pre code type">State</span>? {
    <span class="pre code keyword">switch</span> state {
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">start</span>:
      <span class="pre code keyword">switch</span> event {
      <span class="pre code keyword">case</span> .<span class="pre code dotAccess">startSearch</span>: <span class="pre code keyword">return</span> .<span class="pre code dotAccess">searching</span>
      <span class="pre code keyword">case</span> .<span class="pre code dotAccess">cancel</span>, .<span class="pre code dotAccess">search</span>, .<span class="pre code dotAccess">success</span>, .<span class="pre code dotAccess">failure</span>: <span class="pre code keyword">return nil</span>
      }
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searching</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">loading</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">searchResults</span>: ...
    <span class="pre code keyword">case</span> .<span class="pre code dotAccess">error</span>: ...
    }
  }
}
</code></pre><p>With this implementation, we can get a pretty good overview of how the machine works. It’s also pretty easy to step through this function using the debugger if we’re unsure about some state transitions. The main downside of this type of notation is that it can become pretty verbose when the number of states/events increase. It’s pretty manageable in this case, but we would consider a library or some other implementation of the state transitions that will allow for more ergonomic code if needed.</p><h3>Side effects</h3><p>We mentioned earlier that the view model acts as a middleware between the state machine and the view when it comes to observing state. One of the reasons that we’ve chosen to do this is to enable our state changes to have side effects. State machines very often have side effects when either entering or leaving states. To enable this we will add property observers (<code>willSet</code> and <code>didSet</code>) to the view model's <code>state</code> variable and some functions to handle the transitions:</p><pre><code><span class="pre code keyword">class</span> ContentViewModel {
  ...
  <span class="pre code keyword">@Published var</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span> {
    <span class="pre code keyword">willSet</span> { <span class="pre code call">leaveState</span>(state) }
    <span class="pre code keyword">didSet</span> { <span class="pre code call">enterState</span>(state) }
  }  
  ...
  <span class="pre code keyword">func</span> leaveState(<span class="pre code keyword">_</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>) {
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">searching</span> = state {
      isSearching = <span class="pre code keyword">false</span>
    }
  }
  <span class="pre code keyword">func</span> enterState(<span class="pre code keyword">_</span> state: <span class="pre code type">StateMachine</span>.<span class="pre code type">State</span>) {
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">searching</span> = state {
      isSearching = <span class="pre code keyword">true</span>
    }
    <span class="pre code keyword">if case</span> .<span class="pre code dotAccess">loading</span> = state {
      <span class="pre code call">search</span>()
    }
  }
}
</code></pre><p>We set the <code>isSearching</code> property when entering or leaving the searching state. With the help of Combine and SwiftUI this propagates all the way into the <code>SearchBar</code> component and makes the keyboard appear and disappear. Additionally, we also let entering the loading state trigger our network request. In this application we are helped a lot by SwiftUI, Combine and the <code>@ObservedObject</code> property wrapper in the <code>ContentView</code>. By using this property wrapper we get UI changes for free whenever the state of our view model changes. If we had a more traditional UIKit application we would use these state transition functions to also swap out the visible view of our application. The main idea behind this architecture is to let the state machine drive UI changes, and so it’s an essential part to let the machine have side effects.</p><h2>Wrapping up</h2><p>We’ve seen how a state machine can help us structure and validate code, and how it helps us get an overview of an application’s flow. This sample application is pretty simple, but it is heavily inspired by a (more complicated) real-world implementation that we’ve worked on for a client. We think it illustrates the point of how a state machine will help us structure code. Adding a state machine may not let you write any less code — or less complicated code for that matter — but we do believe that it helps structure code more to a more understandable format. It helps us gather the logic that has to do with flow and transitions in a centralized place, and it lets us respond to changes in state in a well defined and structured way.</p><p>The state machine can also help us if we need to add something or make changes to the way our application works. Since all logic is centralised, we can easily see what effects a particular change will have on our application. Many times we can also get compiler support, for instance by using enum cases as states or events, so that we are sure we haven’t left some combination of state and events unimplemented.</p><p>If you want to see the complete implementation of this app you can check out the <a href="https://github.com/peterringset/StateMachineUI">GitHub repository</a>.</p><img src="https://raw.githubusercontent.com/peterringset/StateMachineUI/master/demo/demo.gif" alt="Demo"/>]]></content:encoded></item></channel></rss>